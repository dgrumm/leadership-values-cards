# 04.5.2 Store Factory Migration

**Status**: ðŸ”´ Not Started  
**Priority**: CRITICAL - Production Blocking Migration  
**Complexity**: High  
**Dependencies**: 04.5.1 Session Store Manager âœ…  
**Estimated Time**: 4-5 days

## Problem Statement

Current Zustand stores are exported as global singletons:
```typescript
// CURRENT PROBLEM: Global singleton shared by all users
export const useStep1Store = create<Step1State>((set, get) => ({ ... }));
```

This causes state bleeding where User1's actions affect User2's UI state.

## Solution Overview

Convert global store exports to factory functions that create fresh instances:
```typescript
// NEW SOLUTION: Factory function creates isolated instances  
export function createStep1Store(): Step1Store {
  return create<Step1State>((set, get) => ({ ... }));
}
```

## Technical Requirements

### 1. Store Factory Functions
Replace global exports with factory functions for each store:

#### Step1 Store Factory
```typescript
// /state/local/step1-store-factory.ts
import { create } from 'zustand';
import { Step1State } from './step1-store-types';

export function createStep1Store(): ReturnType<typeof create<Step1State>> {
  return create<Step1State>((set, get) => ({
    // Exact same implementation as current useStep1Store
    // But creates NEW instance each time called
    deck: [],
    deckPosition: 0,
    // ... rest of implementation
  }));
}

// Export types for reuse
export type Step1Store = ReturnType<typeof createStep1Store>;
```

### 2. Backward Compatibility Layer
Maintain existing global exports temporarily to prevent breaking changes:
```typescript
// /state/local/step1-store.ts (LEGACY - to be removed in 04.5.4)
import { createStep1Store } from './step1-store-factory';

// Global instance for backward compatibility during migration
export const useStep1Store = createStep1Store();

// Mark as deprecated to encourage migration
/** @deprecated Use useSessionStep1Store instead - global stores cause state bleeding */
export { useStep1Store };
```

### 3. Type Safety & Interface Consistency
Ensure all store types remain compatible:
```typescript
// /state/local/store-types.ts
export interface Step1State {
  // Existing interface unchanged
  deck: Card[];
  deckPosition: number;
  stagingCard: Card | null;
  // ... all existing properties and methods
}

// Utility type for factory return values
export type StoreFactory<T> = () => ReturnType<typeof create<T>>;
```

### 4. Test Migration Strategy
Update tests to use factories while maintaining coverage:
```typescript
// /tests/unit/stores/step1-store-factory.test.ts
describe('Step1 Store Factory', () => {
  it('should create separate instances for each call', () => {
    const store1 = createStep1Store();
    const store2 = createStep1Store();
    
    // Different instances
    expect(store1).not.toBe(store2);
    
    // Independent state
    store1.getState().flipNextCard();
    expect(store1.getState().stagingCard).toBeTruthy();
    expect(store2.getState().stagingCard).toBe(null);
  });
});
```

## Implementation Details

### Phase 1: Extract Store Logic (Day 1-2)
1. **Create Store Types Files**: Extract all interfaces to separate type files
2. **Create Factory Functions**: Convert store implementations to factory functions
3. **Maintain API Compatibility**: Ensure exact same API as current stores
4. **Unit Test Factories**: Comprehensive testing of factory functions

### Phase 2: Integration with SessionStoreManager (Day 2-3)  
1. **Manager Integration**: Update SessionStoreManager to use factories
2. **Instance Management**: Ensure factories create properly isolated instances
3. **Memory Verification**: Confirm no memory leaks from multiple instances
4. **Performance Testing**: Benchmark factory creation performance

### Phase 3: Backward Compatibility (Day 3-4)
1. **Legacy Wrapper**: Create backward compatible global exports
2. **Deprecation Warnings**: Add clear deprecation notices
3. **Migration Path**: Document exact steps for migrating existing code
4. **Test Compatibility**: Ensure existing tests still pass

### Phase 4: Test Suite Migration (Day 4-5)
1. **Factory-Based Tests**: Create comprehensive test suite for factories
2. **Isolation Tests**: Verify complete state isolation between instances
3. **Memory Leak Tests**: Long-running tests to detect memory issues
4. **Integration Tests**: Test with SessionStoreManager integration

## File Structure
```
/state/local/
â”œâ”€â”€ step1-store-factory.ts      # Factory function for Step1
â”œâ”€â”€ step2-store-factory.ts      # Factory function for Step2  
â”œâ”€â”€ step3-store-factory.ts      # Factory function for Step3
â”œâ”€â”€ store-types.ts              # Shared type definitions
â”œâ”€â”€ step1-store.ts              # LEGACY - backward compatibility wrapper
â”œâ”€â”€ step2-store.ts              # LEGACY - backward compatibility wrapper
â”œâ”€â”€ step3-store.ts              # LEGACY - backward compatibility wrapper
â””â”€â”€ index.ts                    # Export management

/tests/unit/stores/
â”œâ”€â”€ step1-store-factory.test.ts # Factory-specific tests
â”œâ”€â”€ step2-store-factory.test.ts # Factory-specific tests
â”œâ”€â”€ step3-store-factory.test.ts # Factory-specific tests
â”œâ”€â”€ store-isolation.test.ts     # Cross-store isolation tests
â””â”€â”€ factory-performance.test.ts # Performance benchmarks
```

## Acceptance Criteria

### âœ… Factory Function Quality
- [ ] Each factory creates completely independent store instances
- [ ] Factory-created stores have identical API to current global stores
- [ ] All existing store functionality preserved in factory versions
- [ ] TypeScript types remain compatible with existing code

### âœ… State Isolation Verification
- [ ] Multiple factory instances have completely separate state
- [ ] Actions on one instance do not affect other instances
- [ ] Memory usage is reasonable with multiple instances
- [ ] No state leakage between factory-created stores

### âœ… Backward Compatibility  
- [ ] Existing global store exports continue to work
- [ ] All existing tests pass without modification
- [ ] Clear deprecation warnings guide migration
- [ ] Migration path is well-documented

### âœ… Integration with SessionStoreManager
- [ ] SessionStoreManager uses factories correctly
- [ ] Store instances are properly cached and reused
- [ ] Cleanup works correctly with factory-created instances
- [ ] Performance remains acceptable with realistic participant loads

## Test Cases

### Factory Function Tests
1. **Instance Independence**: Verify separate instances have independent state
2. **API Compatibility**: Confirm identical interface to global stores
3. **Memory Usage**: Monitor memory with multiple concurrent instances
4. **Performance**: Benchmark factory creation time

### State Isolation Tests  
1. **Step1 Isolation**: Verify deck/staging/piles are completely separate
2. **Step2 Isolation**: Verify top8 pile and completion state separation
3. **Step3 Isolation**: Verify final selection state isolation
4. **Cross-Store Isolation**: Ensure Step1/2/3 factories don't interfere

### Backward Compatibility Tests
1. **Global Store Behavior**: Verify global stores still work as before
2. **Test Suite Compatibility**: All existing tests pass unchanged  
3. **Migration Validation**: Test gradual migration from global to factory
4. **Deprecation Warnings**: Ensure warnings appear in development

### Integration Tests
1. **SessionStoreManager Integration**: Verify proper factory usage
2. **Multi-User Simulation**: Test with multiple simulated participants
3. **Memory Management**: Long-running tests for memory leak detection
4. **Error Handling**: Test behavior with factory creation failures

## Success Metrics

- **State Isolation**: 100% - No state sharing between factory instances
- **API Compatibility**: 100% - Existing code works unchanged
- **Performance**: Factory creation <2ms per instance
- **Memory Usage**: <1MB additional per factory instance
- **Test Coverage**: >95% for all factory functions

## Migration Path for Developers

### Current Usage (DEPRECATED)
```typescript
// OLD: Global store causes state bleeding
const { deck, flipNextCard } = useStep1Store();
```

### New Usage (REQUIRED)  
```typescript
// NEW: Session-scoped store prevents state bleeding
const { deck, flipNextCard } = useSessionStep1Store(sessionCode, participantId);
```

### Gradual Migration Strategy
1. **Phase 1**: Factories available, global stores marked deprecated
2. **Phase 2**: Components migrate to session-scoped hooks (04.5.3)
3. **Phase 3**: Global stores removed after all components migrated (04.5.4)

## Risks & Mitigations

### Risk 1: Breaking Changes
**Concern**: Factory migration breaks existing functionality  
**Mitigation**: Maintain backward compatibility, extensive testing, gradual rollout

### Risk 2: Performance Impact  
**Concern**: Multiple store instances impact performance  
**Mitigation**: Performance benchmarking, efficient factory implementation, memory monitoring

### Risk 3: Complex Migration
**Concern**: Large codebase makes migration error-prone  
**Mitigation**: Automated testing, clear documentation, phased approach

## Dependencies & Next Steps

### Depends On
- **04.5.1 Session Store Manager**: Must be complete and tested

### Enables  
- **04.5.3 Session-Scoped Hooks**: Can create useSessionStep1Store() hooks
- **04.5.4 Component Integration**: Can migrate components to new architecture

---

**Critical Success Factor**: This migration must maintain 100% backward compatibility while providing the foundation for state isolation. Any breaking changes will cascade throughout the entire application.