# 04.5 Local vs Shared State Architecture

**Status**: ðŸŸ¢ Complete  
**Priority**: CRITICAL - Production Blocking  
**Complexity**: High  
**Dependencies**: 04.1, 04.2  
**Completed**: 2025-08-29  

## Problem Statement

### Critical Bug Identified
- **State Bleeding**: User1's actions (completing Step 2) affect User2's UI (shows "Continue to Step 3" button)
- **Root Cause**: Zustand stores are global singletons shared across all participants
- **Impact**: Breaks fundamental collaborative experience and user flow integrity

### Current Architecture Issues
1. **No State Isolation**: All users share the same Zustand store instances
2. **Confused Responsibility**: UI state mixed with collaboration state  
3. **No Session Scoping**: State persists across different sessions
4. **Production Risk**: Makes collaborative sessions unusable

## Solution Architecture

### State Separation Strategy

#### **Local State** (Per-Participant, Never Synced)
- **UI State**: Drag operations, modal visibility, animations, focus state
- **Step Progress**: Current step, completion status, validation state  
- **Card Positions**: Where cards are positioned in THIS user's interface
- **Interaction State**: Hover, selection, staging area contents

#### **Shared State** (Synced via Ably)
- **Presence Data**: Who's online, current step, status indicators
- **Reveal Actions**: When users share their top 8/3 selections
- **Session Metadata**: Session code, participant count, session status

#### **Derived State** (Computed from Local + Shared)
- **Participant Progress**: Combining local step with shared presence
- **Collaboration UI**: Showing others' progress without affecting local state

## Implementation Plan

### Phase 1: State Architecture Foundation
**Goal**: Establish clear boundaries between local and shared state

#### 1.1 Create Session-Scoped Local State
```typescript
// NEW: Session-scoped store factory
interface SessionStoreManager {
  getStep1Store(sessionCode: string, participantId: string): Step1Store;
  getStep2Store(sessionCode: string, participantId: string): Step2Store;  
  getStep3Store(sessionCode: string, participantId: string): Step3Store;
  cleanupSession(sessionCode: string): void;
}
```

#### 1.2 Define State Boundaries
```typescript
// LOCAL STATE (per-participant)
interface LocalStep1State {
  // UI State
  isDragging: boolean;
  draggedCardId: string | null;
  showModal: boolean;
  
  // Step Progress (local to this user)
  currentStep: 1 | 2 | 3;
  isCompleted: boolean;
  
  // Card Positions (this user's interface)
  deck: Card[];
  deckPosition: number;
  stagingCard: Card | null;
  moreImportantPile: Card[];
  lessImportantPile: Card[];
}

// SHARED STATE (synced via Ably)  
interface SharedSessionState {
  sessionCode: string;
  participants: Map<string, PresenceData>;
  reveals: Map<string, RevealData>; // When users share selections
  sessionStatus: 'active' | 'completed' | 'abandoned';
}
```

#### 1.3 Create State Isolation Tests
- Test that User1 actions don't affect User2 UI
- Test session cleanup and isolation
- Test concurrent user interactions

### Phase 2: Store Migration
**Goal**: Migrate from global to session-scoped stores

#### 2.1 Session Store Manager
```typescript
class SessionStoreManager {
  private stores = new Map<string, {
    step1: Step1Store;
    step2: Step2Store; 
    step3: Step3Store;
  }>();
  
  getStores(sessionCode: string, participantId: string) {
    const key = `${sessionCode}:${participantId}`;
    if (!this.stores.has(key)) {
      this.stores.set(key, {
        step1: createStep1Store(),
        step2: createStep2Store(),
        step3: createStep3Store()
      });
    }
    return this.stores.get(key)!;
  }
}
```

#### 2.2 Component Integration
```typescript
// OLD: Global store
const { deck, flipNextCard } = useStep1Store();

// NEW: Session-scoped store
const { deck, flipNextCard } = useSessionStep1Store(sessionCode, participantId);
```

#### 2.3 Hook Creation
```typescript
export function useSessionStep1Store(sessionCode: string, participantId: string) {
  const sessionManager = useSessionStoreManager();
  return sessionManager.getStores(sessionCode, participantId).step1;
}
```

### Phase 3: Shared State Integration
**Goal**: Proper collaboration without state bleeding

#### 3.1 Collaboration State Hook
```typescript
export function useCollaborationState(sessionCode: string) {
  // Manages shared state via Ably
  // Does NOT affect local UI state
  return {
    sharedParticipants,
    sharedReveals,
    sessionStatus,
    // Actions for sharing data
    shareTopSelection: (cards: Card[]) => void,
    updatePresence: (data: PresenceData) => void
  };
}
```

#### 3.2 State Boundary Enforcement
```typescript
// RULE: Local stores never directly sync with Ably
// RULE: Shared state never affects local UI logic  
// RULE: Derived state combines but doesn't mutate either
```

### Phase 4: Testing & Validation
**Goal**: Ensure complete state isolation

#### 4.1 State Isolation Tests
- **Multi-user simulation**: Test 3 users in same browser session
- **Step progression isolation**: User1 Step2 completion doesn't affect User2
- **Session boundary tests**: Different sessions completely isolated
- **Memory leak tests**: Proper cleanup when users leave

#### 4.2 Integration Tests  
- **Real-time collaboration**: Presence updates work without UI bleeding
- **Reveal functionality**: Sharing selections doesn't affect other users' progress
- **Session lifecycle**: Join/leave/cleanup works correctly

## Acceptance Criteria

### âœ… State Isolation
- [ ] User1 completing Step 2 does NOT show "Continue to Step 3" for User2
- [ ] Each participant has independent deck, card positions, and UI state
- [ ] Different sessions are completely isolated
- [ ] User leaving session cleans up their local state

### âœ… Collaboration Features Preserved  
- [ ] Presence system shows real participant count and status
- [ ] ParticipantsModal shows all users with proper indicators
- [ ] Reveal functionality works for sharing selections
- [ ] Real-time updates for joining/leaving participants

### âœ… Performance & Memory
- [ ] No memory leaks from abandoned sessions
- [ ] Efficient cleanup when users navigate away
- [ ] Reasonable memory usage with multiple concurrent sessions
- [ ] Fast initialization for new participants

### âœ… Developer Experience
- [ ] Clear separation between local and shared state
- [ ] Easy to understand which state goes where
- [ ] Good TypeScript support for state boundaries
- [ ] Comprehensive test coverage

## Technical Risks & Mitigations

### Risk 1: Complex State Management
- **Mitigation**: Clear interfaces and comprehensive tests
- **Fallback**: Gradual migration with feature flags

### Risk 2: Performance Impact
- **Mitigation**: Efficient store creation and cleanup
- **Monitoring**: Memory usage and performance metrics

### Risk 3: Breaking Existing Features
- **Mitigation**: Extensive testing and gradual rollout
- **Rollback**: Ability to revert to current system

## Migration Strategy

### Week 1: Foundation
- Create session store manager
- Build state isolation tests
- Define clear state boundaries

### Week 2: Store Migration
- Migrate Step1Store to session-scoped
- Update Step1Page to use new store
- Comprehensive testing

### Week 3: Complete Migration  
- Migrate Step2Store and Step3Store
- Update all Step pages
- Integration testing

### Week 4: Polish & Optimization
- Performance optimization
- Memory leak testing  
- Documentation and training

## Success Metrics

- **Bug Resolution**: State bleeding completely eliminated
- **User Experience**: Independent step progression per user
- **Collaboration**: Real-time features work without side effects
- **Performance**: No regression in app performance
- **Test Coverage**: >95% coverage for state management

---

**Next Steps**: 
1. Get approval for this architecture change
2. Create detailed implementation tickets  
3. Set up feature branch for gradual migration
4. Begin with Phase 1 implementation