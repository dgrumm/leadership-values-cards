# 04.3.1 Event-Driven Architecture Migration Plan

## Status: üî¥ Planning Phase
**Branch**: `feature/event-driven-architecture` (to be created)
**Priority**: Critical - Fixes production-blocking synchronization issues

---

## Problem Analysis & Root Cause

### Current Architecture Issues

Our current hybrid Session API + Presence Events architecture has fundamental race conditions that cause participant step status to flip-flop between different values. Despite extensive debugging and patches, the issues persist:

#### 1. Dual State Systems Race Condition
```
Dave completes Step 1 ‚Üí moves to Step 2
‚îú‚îÄ Local UI: Shows Step 2 immediately ‚úÖ
‚îú‚îÄ Presence Event: Broadcasts Step 2 to Ably ‚úÖ  
‚îú‚îÄ Session API: Updates Dave to Step 2 (async) ‚è≥
‚îî‚îÄ Bob's View: Fetches stale session data (Step 1) ‚ùå
    ‚îî‚îÄ Result: Bob sees Dave flip between Step 1 & Step 2
```

#### 2. Evidence from Debugging Sessions
- **API calls working**: `PUT /api/sessions/2DEBUG 200 in 5ms` ‚úÖ
- **Presence events working**: `üöÄ STEP CHANGE DETECTED: Dave 1 ‚Üí 2` ‚úÖ
- **Immediate updates triggered**: `‚ö° Immediate update triggered by step changes` ‚úÖ
- **But still flickering**: Participants see inconsistent step status ‚ùå

#### 3. Failed Patch Attempts
1. **Smart conflict resolution** - Session data priority over presence
2. **Cache removal** - Always fetch fresh session data
3. **Throttling bypass** - Immediate updates for step changes
4. **ID matching fixes** - Proper participant lookup between systems
5. **Cookie-based identity** - Prevent duplicate participants

**Result**: All patches added complexity without solving the core issue.

### Root Cause Analysis
The fundamental problem is **architectural**: we have two authoritative sources of truth (Session API + Presence Events) that update asynchronously, creating inevitable race conditions that can't be reliably resolved with timing fixes.

---

## Event-Driven Architecture Solution

### Core Principle
**Single Source of Truth**: All state changes become immutable events in a ordered stream that all participants process identically.

### Architecture Overview
```
User Action ‚Üí Event ‚Üí Event Bus (Ably) ‚Üí All Participants ‚Üí State Update
    ‚Üë                                                           ‚Üì
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ Optimistic UI Update ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ Conflict Detection ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Key Components

#### 1. Event Types
```typescript
// Base event interface
interface BaseEvent {
  id: string;
  type: string;
  sessionCode: string;
  participantId: string;
  timestamp: number;
  version: number;
}

// Specific event types
interface StepTransitionedEvent extends BaseEvent {
  type: 'STEP_TRANSITIONED';
  payload: {
    fromStep: 1 | 2 | 3;
    toStep: 1 | 2 | 3;
    participantName: string;
  };
}

interface ParticipantJoinedEvent extends BaseEvent {
  type: 'PARTICIPANT_JOINED';
  payload: {
    participant: Participant;
  };
}

interface CardMovedEvent extends BaseEvent {
  type: 'CARD_MOVED';
  payload: {
    cardId: string;
    fromPile: string;
    toPile: string;
    position: number;
  };
}

interface SelectionRevealedEvent extends BaseEvent {
  type: 'SELECTION_REVEALED';
  payload: {
    revealType: 'top8' | 'top3';
    cards: Card[];
  };
}
```

#### 2. Event Bus (Ably Integration)
```typescript
class EventBus {
  private channel: Ably.Channel;
  
  async publishEvent(event: BaseEvent): Promise<void> {
    await this.channel.publish(event.type, event);
  }
  
  subscribeToEvents(handler: (event: BaseEvent) => void): () => void {
    return this.channel.subscribe(handler);
  }
}
```

#### 3. State Reducers
```typescript
type SessionState = {
  participants: Map<string, Participant>;
  currentStep: Record<string, number>;
  cardPositions: Record<string, CardPosition>;
  reveals: Record<string, RevealData>;
};

function sessionReducer(state: SessionState, event: BaseEvent): SessionState {
  switch (event.type) {
    case 'STEP_TRANSITIONED':
      return {
        ...state,
        currentStep: {
          ...state.currentStep,
          [event.participantId]: event.payload.toStep
        }
      };
    // ... other event handlers
  }
}
```

#### 4. Optimistic Updates
```typescript
class OptimisticStateManager {
  private confirmedState: SessionState;
  private pendingEvents: BaseEvent[] = [];
  
  // Apply event optimistically
  applyOptimistically(event: BaseEvent): SessionState {
    this.pendingEvents.push(event);
    return sessionReducer(this.confirmedState, event);
  }
  
  // Confirm event when received from server
  confirmEvent(eventId: string): void {
    this.pendingEvents = this.pendingEvents.filter(e => e.id !== eventId);
    // Rebuild confirmed state
  }
  
  // Rollback on conflict
  rollbackEvent(eventId: string): SessionState {
    this.pendingEvents = this.pendingEvents.filter(e => e.id !== eventId);
    // Show conflict resolution UI
  }
}
```

---

## Migration Strategy

### Phase 1: Infrastructure Setup (Session 1)
**Goal**: Set up event system without breaking existing functionality

#### Tasks:
1. **Create event system foundation**
   - Define event types and schemas
   - Implement EventBus with Ably integration
   - Create state reducers and optimistic update manager
   - Add comprehensive TypeScript types

2. **Set up parallel event system**
   - Run alongside existing Session API + Presence
   - Log events without affecting current functionality
   - Validate event ordering and delivery

3. **Add automated tests**
   - Event creation and serialization
   - State reducer logic
   - Optimistic update scenarios
   - Ably integration mocks

#### Success Criteria:
- ‚úÖ Events can be published and received
- ‚úÖ State reducers produce correct state from events
- ‚úÖ Optimistic updates work with rollback capability
- ‚úÖ All existing functionality still works unchanged
- ‚úÖ 100% test coverage for event system

#### Rollback Point:
Event system can be disabled with feature flag, no impact on existing code.

### Phase 2: Step Transition Migration (Session 2)
**Goal**: Replace step synchronization with StepTransitioned events

#### Tasks:
1. **Implement step transition events**
   - Replace `handleStepNavigation` API calls with event publishing
   - Update `usePresence` to subscribe to step events instead of polling
   - Maintain backward compatibility during transition

2. **A/B test event vs API**
   - Feature flag to switch between systems
   - Compare consistency and performance
   - Ensure no regressions in user experience

3. **Remove legacy step sync**
   - Once events proven stable, remove Session API step updates
   - Remove presence-based step synchronization
   - Clean up throttling and caching code

#### Success Criteria:
- ‚úÖ Step transitions appear instantly and consistently across all participants
- ‚úÖ No more flip-flopping or race conditions
- ‚úÖ Performance equal or better than current system
- ‚úÖ Backward compatibility maintained during transition

#### Rollback Point:
Feature flag can immediately revert to Session API + Presence system.

### Phase 3: Participant Operations Migration (Session 3)
**Goal**: Migrate participant joining/leaving to events

#### Tasks:
1. **ParticipantJoined/Left events**
2. **Activity and presence updates via events**
3. **Remove session polling for participant updates**

#### Success Criteria:
- ‚úÖ Real-time participant updates without polling
- ‚úÖ Consistent participant state across all clients
- ‚úÖ Proper cleanup when participants leave

### Phase 4: Card Operations Migration (Session 4)
**Goal**: Migrate card movements and reveals to events

#### Tasks:
1. **CardMoved events for drag & drop**
2. **SelectionRevealed events for reveal mechanism**
3. **Remove remaining Session API polling**

#### Success Criteria:
- ‚úÖ Real-time card movements
- ‚úÖ Consistent reveal state
- ‚úÖ Complete removal of legacy polling systems

---

## Event Flow Examples

### Example 1: Step Transition
```
1. Dave clicks "Complete Step 1"
2. UI optimistically shows Dave at Step 2
3. StepTransitionedEvent published to EventBus
4. All participants (including Dave) receive event
5. State reducer updates Dave to Step 2
6. UI confirms optimistic update was correct
7. Result: All participants see Dave at Step 2 instantly
```

### Example 2: Conflict Resolution
```
1. Dave and Bob both try to move same card simultaneously
2. Both UIs show optimistic updates
3. Both CardMovedEvents published with same timestamp
4. EventBus orders events (first by timestamp, then by participantId)
5. Dave's event wins (lexicographically first participantId)
6. Bob's UI shows conflict notification and rolls back
7. Result: Consistent state with clear conflict resolution
```

---

## Technical Implementation Details

### Ably Channel Structure
```
sessions:${sessionCode}         // Main event channel
sessions:${sessionCode}:debug   // Debug/logging channel
```

### Event Ordering & Consistency
- **Timestamp-based ordering** with participant ID tiebreaker
- **Event IDs** for deduplication and conflict resolution
- **Version numbers** for optimistic concurrency control

### Error Handling
- **Network failures**: Queue events locally, replay when reconnected
- **Event conflicts**: Show user-friendly conflict resolution UI
- **State corruption**: Reset from authoritative event log

### Performance Optimizations
- **Event batching** for high-frequency operations (card movements)
- **State snapshots** to avoid replaying entire event history
- **Selective subscriptions** to reduce bandwidth

---

## Success Metrics

### Reliability Metrics
- **Zero flip-flopping**: No inconsistent step status across participants
- **Event delivery**: 99.9% successful event delivery within 100ms
- **State consistency**: All participants have identical state at rest

### Performance Metrics
- **Step transition latency**: <50ms from action to all participants updated
- **Memory usage**: <10MB additional memory overhead
- **Network bandwidth**: <50% increase in network traffic

### Developer Experience
- **Debuggability**: Complete event log for troubleshooting
- **Testability**: Deterministic state from event replay
- **Maintainability**: Clear separation of concerns

---

## Session Continuity Plan

### Development Checkpoints
Each phase has clear stopping points that allow resuming work in future sessions:

#### After Phase 1:
- ‚úÖ Event system infrastructure complete
- ‚úÖ Tests passing
- ‚úÖ Documentation updated
- üîÑ **Resume Point**: Begin step transition migration

#### After Phase 2:
- ‚úÖ Step transitions working via events
- ‚úÖ Legacy system removed
- ‚úÖ Performance validated
- üîÑ **Resume Point**: Begin participant operations migration

### Progress Tracking
- **Commit messages** with phase indicators: `feat(event-arch-p1): implement event bus foundation`
- **Branch naming**: Clear phase branches if needed
- **Testing gates**: Automated tests must pass before proceeding
- **Documentation**: Update this document with actual implementation details

### Rollback Strategy
- **Feature flags** for each migration phase
- **Database migrations** are reversible
- **Backup branches** at each major checkpoint
- **Performance monitoring** to detect regressions

---

## Risk Assessment

### High Risk Items
1. **Ably reliability**: Event delivery failures could break entire system
   - **Mitigation**: Local event queuing with replay capability
2. **State corruption**: Bug in reducer could corrupt all participant state
   - **Mitigation**: State validation and reset capability
3. **Performance regression**: Event overhead could slow down system
   - **Mitigation**: Performance monitoring and optimization

### Medium Risk Items
1. **Migration complexity**: Multiple systems running in parallel
   - **Mitigation**: Clear feature flags and rollback procedures
2. **Event ordering**: Race conditions in event processing
   - **Mitigation**: Robust ordering and conflict resolution

### Low Risk Items
1. **User experience**: Changes should be transparent to users
2. **Backward compatibility**: Legacy APIs maintained during transition

---

## Next Steps

### Immediate Actions (Current Session)
1. ‚úÖ **Document completed** - This planning document
2. üîÑ **Commit current debugging work** - Preserve investigation
3. üîÑ **Create backup branch** - `backup2/04-3-reveal-mechanism`
4. üîÑ **Create feature branch** - `feature/event-driven-architecture`

### Next Session Actions
1. üîÑ **Implement Phase 1**: Event system foundation
2. üîÑ **Add comprehensive tests**: 100% coverage for event system
3. üîÑ **Validate integration**: Events working alongside current system
4. üîÑ **Update documentation**: Implementation details and lessons learned

---

## Conclusion

This event-driven architecture migration is a significant but necessary change to solve persistent synchronization issues. The phased approach with clear checkpoints, comprehensive testing, and rollback strategies minimizes risk while providing a robust foundation for future development.

The investment in proper event-driven architecture will pay dividends in reliability, debuggability, and maintainability, while finally solving the race conditions that have plagued the current system.