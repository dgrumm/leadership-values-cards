# 04.3.1 Event-Driven Architecture Migration Plan

## Status: 🟢 Complete - Phase 3 Participant Operations Complete  
**Branch**: `feature/0431-reveal-mechanism-event-architecture` (current)
**Priority**: Critical - Production-blocking synchronization issues RESOLVED ✅

### Architectural Decisions Made:
- **Ably Integration**: Separate EventBus system alongside existing presence infrastructure (Option B)
- **State Management**: Keep existing Zustand stores, have events update them (Option 1) 
- **Migration Strategy**: Full rearchitecture approach (not incremental patches)
- **Development Method**: Test-Driven Development with mandatory test gates

---

## Problem Analysis & Root Cause

### Current Architecture Issues

Our current hybrid Session API + Presence Events architecture has fundamental race conditions that cause participant step status to flip-flop between different values. Despite extensive debugging and patches, the issues persist:

#### 1. Dual State Systems Race Condition
```
Dave completes Step 1 → moves to Step 2
├─ Local UI: Shows Step 2 immediately ✅
├─ Presence Event: Broadcasts Step 2 to Ably ✅  
├─ Session API: Updates Dave to Step 2 (async) ⏳
└─ Bob's View: Fetches stale session data (Step 1) ❌
    └─ Result: Bob sees Dave flip between Step 1 & Step 2
```

#### 2. Evidence from Debugging Sessions
- **API calls working**: `PUT /api/sessions/2DEBUG 200 in 5ms` ✅
- **Presence events working**: `🚀 STEP CHANGE DETECTED: Dave 1 → 2` ✅
- **Immediate updates triggered**: `⚡ Immediate update triggered by step changes` ✅
- **But still flickering**: Participants see inconsistent step status ❌

#### 3. Failed Patch Attempts
1. **Smart conflict resolution** - Session data priority over presence
2. **Cache removal** - Always fetch fresh session data
3. **Throttling bypass** - Immediate updates for step changes
4. **ID matching fixes** - Proper participant lookup between systems
5. **Cookie-based identity** - Prevent duplicate participants

**Result**: All patches added complexity without solving the core issue.

### Root Cause Analysis
The fundamental problem is **architectural**: we have two authoritative sources of truth (Session API + Presence Events) that update asynchronously, creating inevitable race conditions that can't be reliably resolved with timing fixes.

---

## Event-Driven Architecture Solution

### Core Principle
**Single Source of Truth**: All state changes become immutable events in a ordered stream that all participants process identically.

### Architecture Overview
```
User Action → Event → Event Bus (Ably) → All Participants → State Update
    ↑                                                           ↓
    └──── Optimistic UI Update ←──── Conflict Detection ←──────┘
```

### Key Components

#### 1. Event Types
```typescript
// Base event interface
interface BaseEvent {
  id: string;
  type: string;
  sessionCode: string;
  participantId: string;
  timestamp: number;
  version: number;
}

// Specific event types
interface StepTransitionedEvent extends BaseEvent {
  type: 'STEP_TRANSITIONED';
  payload: {
    fromStep: 1 | 2 | 3;
    toStep: 1 | 2 | 3;
    participantName: string;
  };
}

interface ParticipantJoinedEvent extends BaseEvent {
  type: 'PARTICIPANT_JOINED';
  payload: {
    participant: Participant;
  };
}

interface CardMovedEvent extends BaseEvent {
  type: 'CARD_MOVED';
  payload: {
    cardId: string;
    fromPile: string;
    toPile: string;
    position: number;
  };
}

interface SelectionRevealedEvent extends BaseEvent {
  type: 'SELECTION_REVEALED';
  payload: {
    revealType: 'top8' | 'top3';
    cards: Card[];
  };
}
```

#### 2. Event Bus (Ably Integration)
```typescript
class EventBus {
  private channel: Ably.Channel;
  
  async publishEvent(event: BaseEvent): Promise<void> {
    await this.channel.publish(event.type, event);
  }
  
  subscribeToEvents(handler: (event: BaseEvent) => void): () => void {
    return this.channel.subscribe(handler);
  }
}
```

#### 3. State Reducers
```typescript
type SessionState = {
  participants: Map<string, Participant>;
  currentStep: Record<string, number>;
  cardPositions: Record<string, CardPosition>;
  reveals: Record<string, RevealData>;
};

function sessionReducer(state: SessionState, event: BaseEvent): SessionState {
  switch (event.type) {
    case 'STEP_TRANSITIONED':
      return {
        ...state,
        currentStep: {
          ...state.currentStep,
          [event.participantId]: event.payload.toStep
        }
      };
    // ... other event handlers
  }
}
```

#### 4. Optimistic Updates
```typescript
class OptimisticStateManager {
  private confirmedState: SessionState;
  private pendingEvents: BaseEvent[] = [];
  
  // Apply event optimistically
  applyOptimistically(event: BaseEvent): SessionState {
    this.pendingEvents.push(event);
    return sessionReducer(this.confirmedState, event);
  }
  
  // Confirm event when received from server
  confirmEvent(eventId: string): void {
    this.pendingEvents = this.pendingEvents.filter(e => e.id !== eventId);
    // Rebuild confirmed state
  }
  
  // Rollback on conflict
  rollbackEvent(eventId: string): SessionState {
    this.pendingEvents = this.pendingEvents.filter(e => e.id !== eventId);
    // Show conflict resolution UI
  }
}
```

---

## Migration Strategy

### Phase 1: Infrastructure Setup (TDD Approach)
**Goal**: Set up event system foundation using Test-Driven Development

#### Tasks (Red-Green-Refactor Cycle):
1. **Event System Foundation (Test-First)**
   - RED: Write tests for event type validation & serialization
   - GREEN: Implement BaseEvent, StepTransitionedEvent, ParticipantJoinedEvent
   - RED: Write EventBus integration tests with Ably mocks
   - GREEN: Implement EventBus class with separate event channels
   - REFACTOR: Clean up event utilities and type definitions

2. **State Management Integration (Test-First)**
   - RED: Write tests for event → Zustand store updates
   - GREEN: Implement event reducers that update existing stores
   - RED: Write OptimisticStateManager tests for pending events
   - GREEN: Implement optimistic update handling with rollback
   - REFACTOR: Optimize state update performance

3. **Testing Infrastructure**
   - Comprehensive unit tests (100% coverage target)
   - Ably integration mocks and test utilities
   - E2E test preparation for multi-participant scenarios

#### Success Criteria:
- ✅ Events can be published and received
- ✅ State reducers produce correct state from events
- ✅ Optimistic updates work with rollback capability
- ✅ All existing functionality still works unchanged
- ✅ 100% test coverage for event system

#### Rollback Point:
Event system can be disabled with feature flag, no impact on existing code.

### Phase 2: Step Transition Migration (Test-Driven)
**Goal**: Replace step synchronization with deterministic StepTransitioned events

#### Tasks (TDD Approach):
1. **Step Event Implementation (Test-First)**
   - RED: Write E2E tests for race-condition-free step transitions
   - GREEN: Replace `handleStepNavigation` with StepTransitionedEvent publishing
   - RED: Write multi-participant step consistency tests
   - GREEN: Update components to use event-driven step updates
   - REFACTOR: Remove legacy step sync code and API calls

2. **Integration & Validation (Test-Driven)**
   - RED: Write performance comparison tests (old vs new system)
   - GREEN: Ensure <50ms step transition latency
   - RED: Write stress tests for multiple rapid step changes
   - GREEN: Optimize event handling for performance
   - REFACTOR: Clean up hybrid architecture remnants

#### Success Criteria:
- ✅ Step transitions appear instantly and consistently across all participants
- ✅ No more flip-flopping or race conditions
- ✅ Performance equal or better than current system
- ✅ Backward compatibility maintained during transition

#### Rollback Point:
Feature flag can immediately revert to Session API + Presence system.

### Phase 3: Participant Operations Migration ✅ COMPLETE
**Goal**: Migrate participant joining/leaving to events

#### Tasks:
1. ✅ **ParticipantJoined/Left events** - Implemented with proper type definitions
2. ✅ **Activity and presence updates via events** - Event-driven participant lifecycle
3. ✅ **Stable identity management** - localStorage-based participant IDs prevent duplicates
4. ✅ **Proper cleanup when participants leave** - Multi-step cleanup (events, presence, stores, localStorage)
5. ✅ **Stale data filtering** - Enhanced presence synchronization to filter inactive participants

#### Success Criteria:
- ✅ Real-time participant updates without polling - Event system working
- ✅ Consistent participant state across all clients - No more count mismatches
- ✅ Proper cleanup when participants leave - Leave Session button works without errors
- ✅ No duplicate participants - Stable IDs prevent Bob-2, Frank-2, etc.
- ✅ Clean re-joining experience - Users can leave and rejoin cleanly

### Phase 4: Card Operations Migration (Session 4)
**Goal**: Migrate card movements and reveals to events

#### Tasks:
1. **CardMoved events for drag & drop**
2. **SelectionRevealed events for reveal mechanism**
3. **Remove remaining Session API polling**

#### Success Criteria:
- ✅ Real-time card movements
- ✅ Consistent reveal state
- ✅ Complete removal of legacy polling systems

---

## Event Flow Examples

### Example 1: Step Transition
```
1. Dave clicks "Complete Step 1"
2. UI optimistically shows Dave at Step 2
3. StepTransitionedEvent published to EventBus
4. All participants (including Dave) receive event
5. State reducer updates Dave to Step 2
6. UI confirms optimistic update was correct
7. Result: All participants see Dave at Step 2 instantly
```

### Example 2: Conflict Resolution
```
1. Dave and Bob both try to move same card simultaneously
2. Both UIs show optimistic updates
3. Both CardMovedEvents published with same timestamp
4. EventBus orders events (first by timestamp, then by participantId)
5. Dave's event wins (lexicographically first participantId)
6. Bob's UI shows conflict notification and rolls back
7. Result: Consistent state with clear conflict resolution
```

---

## Technical Implementation Details

### Ably Channel Structure
```
sessions:${sessionCode}         // Main event channel
sessions:${sessionCode}:debug   // Debug/logging channel
```

### Event Ordering & Consistency
- **Timestamp-based ordering** with participant ID tiebreaker
- **Event IDs** for deduplication and conflict resolution
- **Version numbers** for optimistic concurrency control

### Error Handling
- **Network failures**: Queue events locally, replay when reconnected
- **Event conflicts**: Show user-friendly conflict resolution UI
- **State corruption**: Reset from authoritative event log

### Performance Optimizations
- **Event batching** for high-frequency operations (card movements)
- **State snapshots** to avoid replaying entire event history
- **Selective subscriptions** to reduce bandwidth

---

## Success Metrics

### Reliability Metrics
- **Zero flip-flopping**: No inconsistent step status across participants
- **Event delivery**: 99.9% successful event delivery within 100ms
- **State consistency**: All participants have identical state at rest

### Performance Metrics
- **Step transition latency**: <50ms from action to all participants updated
- **Memory usage**: <10MB additional memory overhead
- **Network bandwidth**: <50% increase in network traffic

### Developer Experience
- **Debuggability**: Complete event log for troubleshooting
- **Testability**: Deterministic state from event replay
- **Maintainability**: Clear separation of concerns

---

## Session Continuity Plan

### Development Checkpoints
Each phase has clear stopping points that allow resuming work in future sessions:

#### After Phase 1:
- ✅ Event system infrastructure complete
- ✅ Tests passing
- ✅ Documentation updated
- 🔄 **Resume Point**: Begin step transition migration

#### After Phase 2:
- ✅ Step transitions working via events
- ✅ Legacy system removed
- ✅ Performance validated
- 🔄 **Resume Point**: Begin participant operations migration

### Progress Tracking
- **Commit messages** with phase indicators: `feat(event-arch-p1): implement event bus foundation`
- **Branch naming**: Clear phase branches if needed
- **Testing gates**: Automated tests must pass before proceeding
- **Documentation**: Update this document with actual implementation details

### Rollback Strategy
- **Feature flags** for each migration phase
- **Database migrations** are reversible
- **Backup branches** at each major checkpoint
- **Performance monitoring** to detect regressions

---

## Risk Assessment

### High Risk Items
1. **Ably reliability**: Event delivery failures could break entire system
   - **Mitigation**: Local event queuing with replay capability
2. **State corruption**: Bug in reducer could corrupt all participant state
   - **Mitigation**: State validation and reset capability
3. **Performance regression**: Event overhead could slow down system
   - **Mitigation**: Performance monitoring and optimization

### Medium Risk Items
1. **Migration complexity**: Multiple systems running in parallel
   - **Mitigation**: Clear feature flags and rollback procedures
2. **Event ordering**: Race conditions in event processing
   - **Mitigation**: Robust ordering and conflict resolution

### Low Risk Items
1. **User experience**: Changes should be transparent to users
2. **Backward compatibility**: Legacy APIs maintained during transition

---

## Next Steps

### Immediate Actions (Current Session)
1. ✅ **Document completed** - This planning document
2. 🔄 **Commit current debugging work** - Preserve investigation
3. 🔄 **Create backup branch** - `backup2/04-3-reveal-mechanism`
4. 🔄 **Create feature branch** - `feature/event-driven-architecture`

### Next Session Actions
1. 🔄 **Implement Phase 1**: Event system foundation
2. 🔄 **Add comprehensive tests**: 100% coverage for event system
3. 🔄 **Validate integration**: Events working alongside current system
4. 🔄 **Update documentation**: Implementation details and lessons learned

---

## Conclusion

This event-driven architecture migration is a significant but necessary change to solve persistent synchronization issues. The phased approach with clear checkpoints, comprehensive testing, and rollback strategies minimizes risk while providing a robust foundation for future development.

The investment in proper event-driven architecture will pay dividends in reliability, debuggability, and maintainability, while finally solving the race conditions that have plagued the current system.