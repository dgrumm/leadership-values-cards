# 04.5.3 Session-Scoped Hooks

**Status**: ðŸ”´ Not Started  
**Priority**: CRITICAL - Production Blocking Hooks  
**Complexity**: Medium  
**Dependencies**: 04.5.1 âœ…, 04.5.2 âœ…  
**Estimated Time**: 3-4 days

## Problem Statement

Components currently use global store hooks that cause state bleeding:
```typescript
// CURRENT PROBLEM: All users share same state
const { deck, flipNextCard } = useStep1Store();
```

Need session-scoped hooks that provide isolated state per participant:
```typescript
// REQUIRED SOLUTION: Each user gets isolated state
const { deck, flipNextCard } = useSessionStep1Store(sessionCode, participantId);
```

## Solution Overview

Create React hooks that integrate SessionStoreManager with React components:
- Automatic session/participant detection from context
- Seamless integration with existing component patterns
- Backward compatibility during migration
- Clear developer experience with TypeScript support

## Technical Requirements

### 1. Session Context Provider
```typescript
// /contexts/SessionStoreContext.tsx
interface SessionStoreContextValue {
  sessionManager: SessionStoreManager;
  sessionCode: string;
  participantId: string;
}

export const SessionStoreProvider: React.FC<{
  sessionCode: string;
  participantId: string;
  children: React.ReactNode;
}> = ({ sessionCode, participantId, children }) => {
  const sessionManager = useMemo(() => new SessionStoreManager(), []);
  
  const contextValue = useMemo(() => ({
    sessionManager,
    sessionCode,
    participantId
  }), [sessionManager, sessionCode, participantId]);
  
  return (
    <SessionStoreContext.Provider value={contextValue}>
      {children}
    </SessionStoreContext.Provider>
  );
};
```

### 2. Session-Scoped Store Hooks
```typescript
// /hooks/stores/useSessionStores.ts
export function useSessionStep1Store() {
  const { sessionManager, sessionCode, participantId } = useSessionStoreContext();
  
  // Get or create store instance for this session+participant
  const store = useMemo(
    () => sessionManager.getStep1Store(sessionCode, participantId),
    [sessionManager, sessionCode, participantId]
  );
  
  // Return the store hook (compatible with existing usage)
  return store();
}

export function useSessionStep2Store() {
  const { sessionManager, sessionCode, participantId } = useSessionStoreContext();
  
  const store = useMemo(
    () => sessionManager.getStep2Store(sessionCode, participantId),
    [sessionManager, sessionCode, participantId]
  );
  
  return store();
}
```

### 3. Context Hook with Error Handling
```typescript
// /hooks/stores/useSessionStoreContext.ts
export function useSessionStoreContext(): SessionStoreContextValue {
  const context = useContext(SessionStoreContext);
  
  if (!context) {
    throw new Error(
      'useSessionStoreContext must be used within SessionStoreProvider. ' +
      'Wrap your app with <SessionStoreProvider sessionCode="..." participantId="...">'
    );
  }
  
  // Validate context values
  if (!context.sessionCode || !context.participantId) {
    throw new Error('Invalid session context: missing sessionCode or participantId');
  }
  
  return context;
}
```

### 4. Development Utilities & Debugging
```typescript
// /hooks/stores/useStoreDebugger.ts (DEV ONLY)
export function useStoreDebugger() {
  const { sessionManager, sessionCode, participantId } = useSessionStoreContext();
  
  useEffect(() => {
    if (process.env.NODE_ENV === 'development') {
      // Add debugging tools to window for development
      (window as any).debugStores = {
        getSessionManager: () => sessionManager,
        getStoreCount: () => sessionManager.getSessionCount(),
        getParticipantCount: () => sessionManager.getParticipantCount(sessionCode),
        currentSession: sessionCode,
        currentParticipant: participantId
      };
    }
  }, [sessionManager, sessionCode, participantId]);
}
```

## Implementation Details

### Phase 1: Context & Core Hooks (Day 1-2)
1. **SessionStoreContext**: Create React context for session management
2. **Context Provider**: Implement provider with session/participant props  
3. **Core Hook**: Create useSessionStoreContext with validation
4. **Basic Testing**: Unit tests for context and basic hook functionality

### Phase 2: Store-Specific Hooks (Day 2-3)
1. **Step Store Hooks**: Create useSessionStep1Store, useSessionStep2Store, useSessionStep3Store
2. **Hook Optimization**: Memoization and performance optimization
3. **Error Boundaries**: Proper error handling for hook failures
4. **TypeScript Support**: Ensure full type safety and IntelliSense

### Phase 3: Developer Experience (Day 3)  
1. **Development Tools**: Debug utilities and store inspection
2. **Error Messages**: Clear, actionable error messages for common issues
3. **Documentation**: Hook usage examples and migration guide
4. **ESLint Rules**: Custom rules to prevent usage of deprecated global stores

### Phase 4: Integration Testing (Day 4)
1. **Component Integration**: Test with actual Step pages
2. **Multi-User Simulation**: Test with multiple sessions/participants
3. **Performance Testing**: Benchmark hook re-render behavior
4. **Memory Testing**: Verify proper cleanup when components unmount

## File Structure
```
/contexts/
â”œâ”€â”€ SessionStoreContext.tsx     # React context provider
â””â”€â”€ index.ts                    # Context exports

/hooks/stores/  
â”œâ”€â”€ useSessionStores.ts         # Main session-scoped store hooks
â”œâ”€â”€ useSessionStoreContext.ts   # Context access hook
â”œâ”€â”€ useStoreDebugger.ts         # Development utilities
â””â”€â”€ index.ts                    # Hook exports

/tests/unit/hooks/stores/
â”œâ”€â”€ useSessionStores.test.ts    # Core hook functionality
â”œâ”€â”€ session-context.test.ts     # Context provider tests
â”œâ”€â”€ hook-performance.test.ts    # Performance and re-render tests
â””â”€â”€ error-handling.test.ts      # Error boundary and validation tests
```

## Acceptance Criteria

### âœ… Core Hook Functionality
- [ ] useSessionStep1Store() returns isolated state per participant
- [ ] useSessionStep2Store() returns isolated state per participant  
- [ ] useSessionStep3Store() returns isolated state per participant
- [ ] Hooks work identically to existing global store hooks

### âœ… State Isolation Verification
- [ ] Different participants using same hook get different state
- [ ] Actions in one component don't affect other participants' components
- [ ] Session changes properly isolate state between sessions
- [ ] Component unmounting properly cleans up store references

### âœ… Developer Experience  
- [ ] Clear TypeScript types and IntelliSense support
- [ ] Helpful error messages for common configuration issues
- [ ] Development debugging tools work in browser console
- [ ] Migration from global hooks is straightforward

### âœ… Performance & Memory
- [ ] Hooks don't cause excessive re-renders
- [ ] Memory usage is reasonable with multiple participants
- [ ] Component unmounting doesn't cause memory leaks
- [ ] Store instance reuse works correctly for same participant

## Test Cases

### Core Functionality Tests
1. **Hook Isolation**: Verify different participants get different store instances
2. **Context Integration**: Test proper context provider integration
3. **Error Handling**: Test behavior with missing/invalid context
4. **Store Consistency**: Verify hook returns match direct store access

### Integration Tests  
1. **Component Integration**: Test hooks in actual Step page components
2. **Multi-Participant**: Simulate multiple participants in same session
3. **Session Switching**: Test behavior when session/participant changes
4. **Cleanup**: Verify proper cleanup when components unmount

### Performance Tests
1. **Re-render Behavior**: Monitor component re-renders with hook usage
2. **Memory Usage**: Track memory with multiple hook instances
3. **Store Access Time**: Benchmark hook response time
4. **Concurrent Usage**: Test with many simultaneous hook calls

### Error Handling Tests
1. **Missing Context**: Test usage outside SessionStoreProvider
2. **Invalid Session**: Test with malformed sessionCode/participantId
3. **Store Creation Failure**: Test behavior when store factories fail
4. **Context Updates**: Test behavior when context values change

## Migration Guide for Components

### Current Usage (DEPRECATED)
```typescript
// OLD: Global store hook
function Step1Page() {
  const { deck, flipNextCard } = useStep1Store();
  // ... component logic
}
```

### New Usage (REQUIRED)
```typescript
// NEW: Session-scoped hook
function Step1Page() {
  const { deck, flipNextCard } = useSessionStep1Store();
  // ... exact same component logic
}

// App-level provider required
function App() {
  return (
    <SessionStoreProvider sessionCode={sessionCode} participantId={participantId}>
      <Step1Page />
    </SessionStoreProvider>
  );
}
```

### Hook Usage Patterns
```typescript
// Pattern 1: Direct usage (most common)
const store = useSessionStep1Store();

// Pattern 2: Destructuring (compatible with existing code)
const { deck, flipNextCard, moveCardToPile } = useSessionStep1Store();

// Pattern 3: Conditional usage
const step1Store = useSessionStep1Store();
const shouldShowDeck = step1Store.deck.length > 0;
```

## Success Metrics

- **API Compatibility**: 100% - Existing component code works unchanged except import
- **State Isolation**: 100% - No state sharing between participants
- **Performance**: Hook execution <1ms, no excessive re-renders  
- **Developer Experience**: Clear error messages, good TypeScript support
- **Test Coverage**: >95% for all hooks and context

## Integration Points

### App-Level Integration
```typescript
// /app/canvas/page.tsx
export default function CanvasPage() {
  const { sessionCode, participantId } = useSession();
  
  return (
    <SessionStoreProvider sessionCode={sessionCode} participantId={participantId}>
      <StepRouter />
    </SessionStoreProvider>
  );
}
```

### Component Integration
Components require minimal changes - only import path changes:
```typescript
// OLD
import { useStep1Store } from '@/state/local/step1-store';

// NEW  
import { useSessionStep1Store } from '@/hooks/stores/useSessionStores';
```

## Risks & Mitigations

### Risk 1: Complex Context Management
**Concern**: Context provider complexity makes debugging harder  
**Mitigation**: Clear error messages, development debugging tools, comprehensive testing

### Risk 2: Performance Impact
**Concern**: Additional context layers impact rendering performance  
**Mitigation**: Proper memoization, performance monitoring, benchmark testing

### Risk 3: Migration Complexity  
**Concern**: Large number of components to migrate  
**Mitigation**: Gradual migration, backward compatibility, clear migration guide

## Dependencies & Next Steps

### Depends On
- **04.5.1 Session Store Manager**: Foundation for store management
- **04.5.2 Store Factory Migration**: Factory functions for store creation

### Enables
- **04.5.4 Component Integration**: Can migrate all Step pages to session-scoped architecture

---

**Critical Success Factor**: These hooks must be drop-in replacements for existing global store hooks to minimize component changes. The migration should be as simple as changing import paths.