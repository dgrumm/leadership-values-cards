# Feature Spec: 04.1 - Ably Setup

## Overview
Configure Ably WebSocket infrastructure for real-time collaboration with proper channel management and message routing.

## User Story
As a participant, I can collaborate with others in real-time, seeing their progress and sharing my own when I choose to reveal.

## Technical Requirements

### Ably Configuration
- [ ] Initialize Ably client with API key from environment
- [ ] Configure connection options for reliability
- [ ] Handle authentication and token refresh
- [ ] Set up client options for optimal performance
- [ ] Enable automatic reconnection with exponential backoff

### Channel Structure
- [ ] **Session Channel**: `session:{sessionCode}` for participant management
- [ ] **Presence Channel**: `presence:{sessionCode}` for live cursor tracking
- [ ] **Reveals Channel**: `reveals:{sessionCode}` for card reveals
- [ ] **Viewers Channel**: `viewers:{sessionCode}` for viewing other participants
- [ ] **Status Channel**: `status:{sessionCode}` for step progress updates

### Connection Management
- [ ] **Connection States**: Track connected, disconnected, suspended states
- [ ] **Reconnection Logic**: Automatic retry with exponential backoff
- [ ] **Offline Handling**: Queue messages when offline, sync when reconnected
- [ ] **Error Recovery**: Graceful handling of connection failures
- [ ] **Heartbeat**: Keep-alive mechanism for stable connections

## Channel Setup Implementation
```javascript
import Ably from 'ably';

class AblyService {
  constructor() {
    this.client = new Ably.Realtime({
      key: process.env.NEXT_PUBLIC_ABLY_KEY,
      clientId: `participant-${Date.now()}`,
      connectionOptions: {
        heartbeatInterval: 30000,  // 30 seconds
        realtimeRequestTimeout: 10000,
        disconnectedRetryTimeout: 15000
      }
    });
    
    this.channels = new Map();
    this.setupConnectionListeners();
  }

  getChannel(sessionCode, channelType = 'session') {
    const channelName = `${channelType}:${sessionCode}`;
    if (!this.channels.has(channelName)) {
      const channel = this.client.channels.get(channelName);
      this.channels.set(channelName, channel);
      this.setupChannelListeners(channel, channelType);
    }
    return this.channels.get(channelName);
  }
}
```

### Message Types
- [ ] **participant-joined**: New participant enters session
- [ ] **participant-left**: Participant leaves session
- [ ] **step-progress**: Participant advances to next step
- [ ] **reveal-cards**: Participant shares their Top 8/3 selection
- [ ] **viewer-joined**: Someone starts viewing a reveal
- [ ] **viewer-left**: Someone stops viewing a reveal
- [ ] **cursor-move**: Real-time cursor position updates
- [ ] **session-timeout**: 55-minute warning and cleanup

### Connection States
```javascript
const CONNECTION_STATES = {
  CONNECTING: 'connecting',
  CONNECTED: 'connected',  
  DISCONNECTED: 'disconnected',
  SUSPENDED: 'suspended',
  CLOSING: 'closing',
  CLOSED: 'closed',
  FAILED: 'failed'
};

function handleConnectionStateChange(stateChange) {
  switch (stateChange.current) {
    case CONNECTION_STATES.CONNECTED:
      // Sync local state, resume real-time features
      break;
    case CONNECTION_STATES.DISCONNECTED:
      // Show reconnecting indicator, queue messages
      break;
    case CONNECTION_STATES.FAILED:
      // Show error, attempt manual reconnection
      break;
  }
}
```

### Security & Privacy
- [ ] **Channel Permissions**: Restrict access to session participants
- [ ] **Message Validation**: Validate all incoming messages
- [ ] **Rate Limiting**: Prevent message spam and abuse
- [ ] **Data Sanitization**: Clean user input before broadcasting
- [ ] **Session Isolation**: Ensure complete isolation between sessions

### Error Handling
- [ ] **Connection Failures**: Retry with exponential backoff
- [ ] **Message Failures**: Queue and retry failed publications
- [ ] **Channel Errors**: Recreate channels on persistent errors
- [ ] **Token Expiry**: Handle authentication token refresh
- [ ] **Network Changes**: Adapt to network connectivity changes

## Environment Configuration
```bash
# .env.local
NEXT_PUBLIC_ABLY_KEY=your-ably-api-key
NEXT_PUBLIC_APP_URL=http://localhost:3000

# Production considerations
ABLY_WEBHOOK_ENDPOINT=https://your-app.com/api/ably/webhook
ABLY_MAX_MESSAGE_SIZE=65536
ABLY_CONNECTION_TTL=120000
```

### Channel Lifecycle
- [ ] **Creation**: First participant creates all channels for session
- [ ] **Join**: Subsequent participants subscribe to existing channels
- [ ] **Activity**: Messages flow between participants
- [ ] **Cleanup**: Channels cleaned up when last participant leaves
- [ ] **Timeout**: Automatic cleanup after 60-minute inactivity

### Message Throttling
- [ ] **Cursor Updates**: Throttle to 50ms (20fps max)
- [ ] **Card Positions**: Debounce to 200ms after drag complete
- [ ] **Status Updates**: Immediate for important state changes
- [ ] **Presence Data**: Update every 30 seconds for heartbeat

### Debugging & Monitoring
- [ ] **Dev Tools**: Ably console integration for debugging
- [ ] **Message Logging**: Comprehensive logging in development
- [ ] **Performance Metrics**: Track message latency and delivery
- [ ] **Connection Quality**: Monitor connection stability
- [ ] **Error Tracking**: Log and report connection issues

## Performance Optimization
```javascript
// Efficient message handling
class MessageHandler {
  constructor() {
    this.throttledCursorUpdate = this.throttle(this.updateCursor, 50);
    this.debouncedCardUpdate = this.debounce(this.updateCardPositions, 200);
  }
  
  throttle(func, limit) {
    let inThrottle;
    return function(...args) {
      if (!inThrottle) {
        func.apply(this, args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    }
  }
  
  debounce(func, delay) {
    let timeoutId;
    return function(...args) {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => func.apply(this, args), delay);
    }
  }
}
```

### Production Considerations
- [ ] **Scalability**: Support 100 concurrent sessions
- [ ] **Regional Deployment**: Use Ably edge locations
- [ ] **Message Persistence**: Brief message history for reconnects
- [ ] **Webhook Integration**: Server-side session cleanup
- [ ] **Analytics Integration**: Track collaboration metrics

## Acceptance Criteria
- [ ] Ably client initializes successfully with environment config
- [ ] All channel types created and managed properly
- [ ] Connection states handled with appropriate UI feedback
- [ ] Message throttling prevents performance issues
- [ ] Automatic reconnection works reliably
- [ ] Error states handled gracefully
- [ ] Session isolation maintained between different codes
- [ ] Memory cleanup prevents leaks during long sessions

## Test Cases
1. Initialize Ably client with valid/invalid API keys
2. Create and manage multiple channel types for session
3. Test connection recovery after network interruption
4. Verify message throttling under high-frequency updates
5. Test session isolation between concurrent sessions
6. Validate error handling for various failure scenarios
7. Test channel cleanup when participants leave
8. Verify webhook integration for server-side cleanup
9. Load test with maximum concurrent participants (50)
10. Test mobile connection handling and offline scenarios

## Dependencies
- 01.2 Session Management âœ“
- Ably JavaScript SDK
- Environment configuration

## Status: ðŸ”´ Not Started