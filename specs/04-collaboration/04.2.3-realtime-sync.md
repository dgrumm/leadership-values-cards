# Feature Spec: 04.2.3 - Real-time Sync

## Overview
Ably integration for live participant data synchronization, handling participant join/leave events, status updates, and maintaining accurate participant state across all clients.

## User Story
As a participant, I see real-time updates when others join or leave the session, and their status changes immediately reflect in the participants overview without needing to refresh.

## Technical Requirements

### Channel Management
- [ ] **Participants Channel**: Dedicated `{sessionCode}-participants` channel
- [ ] **Message Types**: Standardized message format for all participant events
- [ ] **Channel Cleanup**: Proper channel cleanup on component unmount
- [ ] **Connection Management**: Handle Ably connection state changes
- [ ] **Error Recovery**: Automatic reconnection and state recovery

### Participant Join/Leave Events
- [ ] **Join Detection**: Detect and broadcast new participant entries
- [ ] **Leave Detection**: Detect participant disconnections and timeouts
- [ ] **Graceful Departures**: Handle intentional leave vs. network disconnection
- [ ] **State Synchronization**: Full participant list sync for new joiners
- [ ] **Duplicate Handling**: Prevent duplicate participant entries

### Status Update Broadcasting
- [ ] **Step Changes**: Broadcast when participants move between steps 1-3
- [ ] **Reveal Events**: Broadcast when participants reveal their Top 8/3
- [ ] **Activity Updates**: Track and broadcast participant activity status
- [ ] **Batch Updates**: Efficient batching of rapid status changes
- [ ] **Conflict Resolution**: Handle simultaneous updates from multiple sources

## Implementation Details

### Channel Service
```typescript
// services/collaboration/ParticipantsChannelService.ts
class ParticipantsChannelService {
  private channel: RealtimeChannel;
  private participants = new Map<string, ParticipantOverviewData>();
  private listeners = new Set<(participants: ParticipantOverviewData[]) => void>();
  private heartbeatInterval: NodeJS.Timeout | null = null;
  
  constructor(private ablyService: AblyService, private sessionCode: string) {
    this.channel = ablyService.getChannel(sessionCode, 'participants');
    this.setupChannelListeners();
    this.startHeartbeat();
  }
  
  private setupChannelListeners() {
    this.channel.subscribe('participant-joined', this.handleParticipantJoin.bind(this));
    this.channel.subscribe('participant-left', this.handleParticipantLeave.bind(this));
    this.channel.subscribe('status-update', this.handleStatusUpdate.bind(this));
    this.channel.subscribe('request-sync', this.handleSyncRequest.bind(this));
    this.channel.subscribe('participants-sync', this.handleParticipantsSync.bind(this));
    this.channel.subscribe('heartbeat', this.handleHeartbeat.bind(this));
  }
  
  async joinSession(participant: ParticipantOverviewData) {
    this.participants.set(participant.id, participant);
    
    await this.channel.publish('participant-joined', {
      participant,
      timestamp: Date.now()
    });
    
    // Request current participant list from existing members
    await this.channel.publish('request-sync', {
      requesterId: participant.id,
      timestamp: Date.now()
    });
    
    this.notifyListeners();
  }
  
  async leaveSession(participantId: string) {
    this.participants.delete(participantId);
    
    await this.channel.publish('participant-left', {
      participantId,
      timestamp: Date.now()
    });
    
    this.notifyListeners();
    this.cleanup();
  }
  
  async updateStatus(participantId: string, updates: Partial<ParticipantOverviewData>) {
    const participant = this.participants.get(participantId);
    if (!participant) return;
    
    const updatedParticipant = { ...participant, ...updates, lastActive: Date.now() };
    this.participants.set(participantId, updatedParticipant);
    
    await this.channel.publish('status-update', {
      participantId,
      updates,
      timestamp: Date.now()
    });
    
    this.notifyListeners();
  }
  
  private handleParticipantJoin(message: any) {
    const { participant } = message.data;
    this.participants.set(participant.id, participant);
    this.notifyListeners();
  }
  
  private handleParticipantLeave(message: any) {
    const { participantId } = message.data;
    this.participants.delete(participantId);
    this.notifyListeners();
  }
  
  private handleStatusUpdate(message: any) {
    const { participantId, updates } = message.data;
    const participant = this.participants.get(participantId);
    
    if (participant) {
      this.participants.set(participantId, { ...participant, ...updates });
      this.notifyListeners();
    }
  }
  
  private async handleSyncRequest(message: any) {
    const { requesterId } = message.data;
    
    // Send current participants list to requester
    await this.channel.publish('participants-sync', {
      targetId: requesterId,
      participants: Array.from(this.participants.values()),
      timestamp: Date.now()
    });
  }
  
  private handleParticipantsSync(message: any) {
    const { participants, targetId } = message.data;
    
    // Only process sync if it's meant for us
    const currentUserId = this.getCurrentUserId();
    if (targetId && targetId !== currentUserId) return;
    
    // Merge received participants with local state
    participants.forEach((p: ParticipantOverviewData) => {
      this.participants.set(p.id, p);
    });
    
    this.notifyListeners();
  }
  
  private startHeartbeat() {
    this.heartbeatInterval = setInterval(() => {
      this.channel.publish('heartbeat', {
        participantId: this.getCurrentUserId(),
        timestamp: Date.now()
      });
      
      this.cleanupInactiveParticipants();
    }, 30000); // Every 30 seconds
  }
  
  private handleHeartbeat(message: any) {
    const { participantId } = message.data;
    const participant = this.participants.get(participantId);
    
    if (participant) {
      this.participants.set(participantId, {
        ...participant,
        lastActive: Date.now()
      });
    }
  }
  
  private cleanupInactiveParticipants() {
    const now = Date.now();
    const timeout = 2 * 60 * 1000; // 2 minutes
    
    for (const [id, participant] of this.participants) {
      if (now - participant.lastActive > timeout) {
        this.participants.delete(id);
        this.channel.publish('participant-left', {
          participantId: id,
          reason: 'timeout',
          timestamp: now
        });
      }
    }
    
    this.notifyListeners();
  }
  
  subscribe(listener: (participants: ParticipantOverviewData[]) => void) {
    this.listeners.add(listener);
    
    return () => {
      this.listeners.delete(listener);
    };
  }
  
  private notifyListeners() {
    const participants = Array.from(this.participants.values());
    this.listeners.forEach(listener => listener(participants));
  }
  
  private cleanup() {
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
      this.heartbeatInterval = null;
    }
    
    this.channel.unsubscribe();
    this.listeners.clear();
  }
  
  private getCurrentUserId(): string {
    // Implementation depends on session management
    return ''; // TODO: Get from session context
  }
}
```

### React Hook Integration
```typescript
// hooks/collaboration/useParticipants.ts
function useParticipants(sessionCode: string, currentUser: ParticipantOverviewData) {
  const [participants, setParticipants] = useState<ParticipantOverviewData[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const channelServiceRef = useRef<ParticipantsChannelService | null>(null);
  
  useEffect(() => {
    if (!sessionCode || !currentUser) return;
    
    const ablyService = AblyService.getInstance();
    const channelService = new ParticipantsChannelService(ablyService, sessionCode);
    channelServiceRef.current = channelService;
    
    const unsubscribe = channelService.subscribe((updatedParticipants) => {
      setParticipants(updatedParticipants);
      setIsLoading(false);
      setIsConnected(true);
    });
    
    // Join session
    channelService.joinSession(currentUser).catch((err) => {
      console.error('Failed to join session:', err);
      setError('Failed to join session');
      setIsLoading(false);
    });
    
    // Handle Ably connection state changes
    const handleConnectionState = (state: ConnectionState) => {
      setIsConnected(state === 'connected');
      
      if (state === 'connected' && error) {
        setError(null); // Clear error on reconnection
      } else if (state === 'failed' || state === 'suspended') {
        setError('Connection lost. Trying to reconnect...');
      }
    };
    
    ablyService.onConnectionStateChange(handleConnectionState);
    
    return () => {
      unsubscribe();
      if (channelServiceRef.current) {
        channelServiceRef.current.leaveSession(currentUser.id);
      }
    };
  }, [sessionCode, currentUser]);
  
  const updateParticipantStatus = useCallback((updates: Partial<ParticipantOverviewData>) => {
    if (channelServiceRef.current) {
      channelServiceRef.current.updateStatus(currentUser.id, updates);
    }
  }, [currentUser.id]);
  
  return {
    participants,
    participantCount: participants.length,
    isLoading,
    error,
    isConnected,
    updateParticipantStatus
  };
}
```

### Message Types
```typescript
// types/collaboration/messages.ts
export interface ParticipantJoinedMessage {
  participant: ParticipantOverviewData;
  timestamp: number;
}

export interface ParticipantLeftMessage {
  participantId: string;
  reason?: 'intentional' | 'timeout' | 'network';
  timestamp: number;
}

export interface StatusUpdateMessage {
  participantId: string;
  updates: Partial<ParticipantOverviewData>;
  timestamp: number;
}

export interface SyncRequestMessage {
  requesterId: string;
  timestamp: number;
}

export interface ParticipantsSyncMessage {
  targetId?: string;
  participants: ParticipantOverviewData[];
  timestamp: number;
}

export interface HeartbeatMessage {
  participantId: string;
  timestamp: number;
}
```

### Error Handling
- [ ] **Connection Failures**: Retry mechanism with exponential backoff
- [ ] **Message Delivery**: Handle failed message publishing
- [ ] **State Corruption**: Validate and sanitize all incoming data
- [ ] **Concurrent Updates**: Resolve conflicts using timestamps
- [ ] **Channel Errors**: Graceful degradation when channel fails

### Performance Optimization
- [ ] **Message Batching**: Batch multiple updates to reduce network calls
- [ ] **State Debouncing**: Debounce rapid participant updates
- [ ] **Memory Management**: Regular cleanup of old participant data
- [ ] **Efficient Rendering**: Minimize React re-renders with careful state updates

### Security Considerations
- [ ] **Session Validation**: Verify participants belong to session
- [ ] **Data Validation**: Sanitize all participant data
- [ ] **Rate Limiting**: Prevent spam of participant events
- [ ] **Access Control**: Restrict channel access to session members

### Testing Strategy
- [ ] **Unit Tests**: Test individual service methods
- [ ] **Integration Tests**: Test Ably channel integration
- [ ] **Network Tests**: Test connection loss and recovery
- [ ] **Concurrency Tests**: Test multiple simultaneous updates
- [ ] **Load Tests**: Test with maximum participants

## Acceptance Criteria
- [ ] Participants appear immediately when they join the session
- [ ] Participants disappear when they leave or disconnect
- [ ] Status updates sync in real-time across all clients
- [ ] Connection recovery works after network interruption
- [ ] Inactive participants are cleaned up automatically
- [ ] Performance remains smooth with maximum participants (50)
- [ ] Error states provide clear feedback to users
- [ ] All message types are handled correctly

## Test Cases
1. **Participant Join**: Verify new participants appear for all users
2. **Participant Leave**: Verify participants disappear when leaving
3. **Status Updates**: Test real-time status change synchronization
4. **Network Recovery**: Connection loss and automatic recovery
5. **Concurrent Updates**: Multiple participants updating simultaneously
6. **Inactive Cleanup**: Automatic removal of inactive participants
7. **State Synchronization**: New joiners receive complete participant list
8. **Error Handling**: Network errors and malformed message handling

## Dependencies
- 04.1 Ably Setup ✓
- 04.2.2 Participant Cards (provides participant data structure)
- Session management system for current user context

## Integration Points
- **Previous Sub-spec**: 04.2.2 Participant Cards (provides participant data)
- **Next Sub-spec**: 04.2.4 Navigation & Actions (consumes real-time data)
- **Ably Service**: Core WebSocket communication
- **Session Context**: Current user identification

## Status: 🔴 Not Started

**Implementation Priority**: High - Core synchronization functionality  
**Estimated Complexity**: High - Complex real-time synchronization with error handling  
**Technical Dependencies**: Ably channel management, WebSocket reliability