# Feature Spec: 04.3 - Reveal Mechanism

## Overview
Allow participants to share their Top 8 or Top 3 card selections with others, enabling discussion and comparison of leadership values.

## User Story
As a participant, I can choose to reveal my card selections to others in the session and view their revealed selections for discussion and insights.

## Technical Requirements

### Reveal Actions
- [ ] **"üëÅ Reveal" Button**: Available on Top 8 and Top 3 review screens
- [ ] **Confirmation Dialog**: "Share your selection with the group?"
- [ ] **Reveal Status**: Track whether Top 8 or Top 3 is revealed per participant
- [ ] **Public/Private Toggle**: Option to make selection visible to group
- [ ] **Live Updates**: Revealed arrangements update in real-time as owner moves cards

### Reveal States (Hybrid Architecture)
```typescript
// AUTHORITATIVE DATA: Session-scoped stores + Session API
interface RevealedSelections {
  top8?: Card[];  // Stored in session database when revealed
  top3?: Card[];  // Stored in session database when revealed
}

// REAL-TIME STATUS: Ably Presence (ephemeral)
interface PresenceData {
  status: 'sorting' | 'revealed-8' | 'revealed-3' | 'completed';
  isViewing?: string; // participantId being viewed (ephemeral)
  lastActive: number;
}

// HYBRID DISPLAY DATA: Computed from session + presence
interface ParticipantDisplayData {
  // FROM SESSION (authoritative, persistent)
  revealedSelections?: RevealedSelections;
  // FROM PRESENCE (real-time, ephemeral) 
  status: 'sorting' | 'revealed-8' | 'revealed-3' | 'completed';
  // COMPUTED
  canViewTop8: boolean;  // !!revealedSelections?.top8
  canViewTop3: boolean;  // !!revealedSelections?.top3
}
```

### Data Architecture Integration
- [ ] **Session API Storage**: Revealed card selections stored in session database (persistent)
- [ ] **Presence Status Updates**: Reveal status broadcast via existing presence system (ephemeral)
- [ ] **Session-Scoped State**: Use existing session-scoped stores for card positions
- [ ] **Hybrid Display**: Leverage existing usePresence hook for merged data

### View Others' Selections
- [ ] **Participant List**: Show "See [Name]'s Top 8/3" buttons for revealed selections
- [ ] **Read-only View**: Full-screen display of participant's arrangement
- [ ] **Header Display**: "[Name]'s Top [8/3] Leadership Values"
- [ ] **Navigation**: "‚Üê Back to Participants" button
- [ ] **Viewer Presence**: Small avatars showing other active viewers

### Reveal UI Flow
- [ ] **Review Screen**: Reveal button appears with Snapshot and Next Step
- [ ] **Confirmation**: Clear dialog explaining what will be shared
- [ ] **Success Feedback**: "Your Top [8/3] values are now visible to the group"
- [ ] **Status Update**: Participant status changes to "revealed-8" or "revealed-3"
- [ ] **Button State**: Reveal button shows "üëÅ Revealed" when active

## Hybrid Architecture Implementation
```typescript
// Integration with existing session-scoped stores
class RevealManager {
  constructor(sessionCode: string, participantId: string) {
    this.sessionCode = sessionCode;
    this.participantId = participantId;
  }
  
  async revealSelection(type: 'top8' | 'top3') {
    // 1. Get current card positions from session-scoped store
    const cards = type === 'top8' 
      ? useSessionStep2Store().getState().topEightPile
      : useSessionStep3Store().getState().topThreePile;
    
    // 2. Store in session API (authoritative, persistent)
    await fetch(`/api/sessions/${this.sessionCode}`, {
      method: 'PUT',
      body: JSON.stringify({ 
        participantId: this.participantId,
        revealedSelections: { [type]: cards }
      })
    });
    
    // 3. Update presence status (real-time, ephemeral)
    const presenceManager = usePresence();
    await presenceManager.updateStatus(`revealed-${type}` as const);
  }
  
  async updateViewerStatus(viewingParticipantId: string | null) {
    // Update presence with viewing status (ephemeral)
    const presenceManager = usePresence();
    await presenceManager.updatePresence({ 
      isViewing: viewingParticipantId 
    });
  }
}
```

### Live Arrangement Updates (Session-Scoped)
- [ ] **Session-Scoped Storage**: Card positions remain in participant's session-scoped store
- [ ] **Reveal State Separation**: Revealed selections are snapshots, not live positions
- [ ] **Reveal Update Flow**: Re-revealing updates the stored selection snapshot
- [ ] **Optimistic Local Updates**: Owner continues using session-scoped stores normally
- [ ] **Viewer Read-Only Access**: Viewers see stored selection snapshot, not live state

### Privacy Features
- [ ] **Opt-in Reveal**: Participants explicitly choose to reveal
- [ ] **Granular Control**: Can reveal Top 8 but keep Top 3 private
- [ ] **Unrevel Option**: Ability to hide previously revealed selection
- [ ] **Viewer Awareness**: See who is viewing your revealed cards
- [ ] **Discussion Mode**: Revealed cards remain editable for real-time discussion

## Viewer Experience (Hybrid Data)
```typescript
// Viewer state management using hybrid architecture
class ViewerManager {
  enterViewMode(participantId: string) {
    // Get participant data from hybrid usePresence hook
    const { participants } = usePresence(sessionCode, participantName);
    const targetParticipant = participants.find(p => p.participantId === participantId);
    
    if (!targetParticipant?.canViewTop8 && !targetParticipant?.canViewTop3) {
      throw new Error('Participant has not revealed any selections');
    }
    
    this.currentView = {
      participantId,
      participantData: targetParticipant,
      isReadOnly: true
    };
    
    // Update presence to show viewing status (ephemeral)
    this.updateViewerStatus(participantId);
  }
  
  exitViewMode() {
    if (this.currentView) {
      // Clear viewing status from presence
      this.updateViewerStatus(null);
      this.currentView = null;
    }
  }
  
  private async updateViewerStatus(viewingId: string | null) {
    const presenceManager = usePresence();
    await presenceManager.updatePresence({ isViewing: viewingId });
  }
}
```

### Viewer Presence
- [ ] **Avatar Display**: Small participant avatars (emoji and color disk) in corner of viewed arrangement
- [ ] **Viewer Count**: Show number of people viewing
- [ ] **Hover Details**: Names of viewers on avatar hover
- [ ] **Join/Leave Animations**: Smooth transitions as viewers come and go
- [ ] **Maximum Display**: Show first 5 avatars, then "+3 others"

### Discussion Features
- [ ] **Live Editing**: Revealed arrangements can still be modified by owner
- [ ] **Visual Updates**: All viewers see changes in real-time
- [ ] **Cursor Tracking**: Show owner's cursor movements to viewers
- [ ] **Change Indicators**: Highlight recently moved cards
- [ ] **Activity Notifications**: Subtle indicators when owner is active

### Reveal Analytics
- [ ] **Reveal Rate**: Track percentage of participants who reveal
- [ ] **View Engagement**: Track who views whose selections
- [ ] **Discussion Time**: Measure time spent viewing others
- [ ] **Popular Values**: Aggregate most common values across reveals

## Integration Points (Hybrid Architecture)
- [ ] **Session API**: Store/retrieve revealed selections (persistent data)
- [ ] **Presence Updates**: Broadcast reveal status changes (real-time status)
- [ ] **usePresence Hook**: Merge session + presence data for display
- [ ] **Session-Scoped Stores**: Continue normal card management for owner
- [ ] **Viewer Tracking**: Use existing presence system for ephemeral viewer status
- [ ] **ParticipantDisplayData**: Leverage existing hybrid display data structure

### Error Handling
- [ ] **Reveal Failures**: Handle failed reveal attempts gracefully
- [ ] **Sync Errors**: Recover from arrangement sync failures
- [ ] **Viewer Conflicts**: Handle multiple viewers efficiently
- [ ] **Network Issues**: Queue updates during disconnection
- [ ] **Invalid States**: Validate reveal data integrity

### Performance Considerations
- [ ] **Efficient Updates**: Only sync changed card positions
- [ ] **Viewer Limits**: Handle large numbers of viewers gracefully
- [ ] **Memory Management**: Clean up viewer data on disconnect
- [ ] **Network Optimization**: Compress large arrangement updates

## Security & Privacy
- [ ] **Access Control**: Only session participants can view reveals
- [ ] **Data Validation**: Validate all reveal messages
- [ ] **Session Isolation**: Reveals contained within session boundaries
- [ ] **Cleanup**: Remove reveal data when session ends

### Accessibility
- [ ] **Screen Reader**: Announce reveal status changes
- [ ] **Keyboard Navigation**: Navigate between revealed arrangements
- [ ] **High Contrast**: Ensure reveal indicators are visible
- [ ] **Focus Management**: Proper focus handling in view mode

## UI Components
```jsx
// Reveal button integrated with hybrid architecture
function RevealButton({ step, participant }: { step: 'top8' | 'top3', participant: ParticipantDisplayData }) {
  const isRevealed = step === 'top8' ? participant.canViewTop8 : participant.canViewTop3;
  const { revealSelection } = useRevealManager();
  
  return (
    <button 
      className={`reveal-btn ${isRevealed ? 'revealed' : ''}`}
      onClick={() => revealSelection(step)}
      disabled={isRevealed}
    >
      {isRevealed ? 'üëÅ Revealed' : 'üëÅ Reveal'}
    </button>
  );
}

// Participant card using hybrid display data
function ParticipantCard({ participant }: { participant: ParticipantDisplayData }) {
  const { enterViewMode } = useViewerManager();
  
  return (
    <div className="participant-card">
      <div className="participant-info">
        {participant.emoji} {participant.name}
      </div>
      <div className="participant-status">
        {participant.status}
      </div>
      {participant.canViewTop8 && (
        <button onClick={() => enterViewMode(participant.participantId, 'top8')}>
          See {participant.name}'s Top 8
        </button>
      )}
      {participant.canViewTop3 && (
        <button onClick={() => enterViewMode(participant.participantId, 'top3')}>
          See {participant.name}'s Top 3
        </button>
      )}
    </div>
  );
}
```

## Acceptance Criteria
- [ ] Participants can reveal their Top 8 or Top 3 selections
- [ ] Revealed selections appear in participant list with view buttons
- [ ] Full-screen viewer shows read-only arrangement correctly
- [ ] Live updates sync to all viewers when owner moves cards
- [ ] Viewer presence shows who is currently viewing
- [ ] Privacy controls work properly (opt-in reveal)
- [ ] Performance remains smooth with multiple viewers
- [ ] Error states handled gracefully

## Test Cases
1. Reveal Top 8 selection and verify it appears to others
2. View another participant's revealed selection
3. Test live arrangement updates while being viewed
4. Verify viewer presence indicators and avatars
5. Test reveal/unreveal functionality
6. Multiple viewers viewing same arrangement simultaneously
7. Network disconnection during reveal/view operations
8. Privacy controls (revealed vs private selections)
9. Load test with maximum participants revealing
10. Accessibility testing with screen readers

## Dependencies
- 04.1 Ably Setup ‚úì
- 04.2 Participants Overview ‚úì
- 04.5 Local vs Shared State Architecture ‚úì (hybrid data foundation)
- 02-core-flow (review screens) ‚úì

## Status: üî¥ Not Started